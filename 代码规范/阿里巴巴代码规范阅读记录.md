### 一.编程规约

#### (一)命名风格

>8.【强制】POJO类中布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列化错误。
>
>反例：定义为基本数据类型Boolean isDeleted的属性，它的方法也是isDeleted()，**RPC框架在反向解析的时候，"误以为"对应的属性名称是deleted**，导致属性获取不到，进而抛出异常。

```java
		private boolean isDeleted;

    public boolean isDeleted() {
        return isDeleted;
    }

    public void setDeleted(boolean deleted) {
        isDeleted = deleted;
    }
```

这里，我设置了一个属性isDeleted，并用ide的getter&setter生成相应方法，getter方法就是isDeleted()，**以前没有注意到这点可能会导致RPC框架反向解析的时候会导致问题**，这里马克一下。



#### (三)代码格式

>3.【强制】if/for/while/switch/do等保留字与括号之间都必须加空格

这里以前也没注意到，没有加空格，可能是加空格是想强调下这些保留字吧，同样马克。





>10【推荐】单个方法的总行数不超过80行。
>
>说明：包括方法签名、结束右大括号、注释、空行、回车及任何不可见字符的总行数不超过80行。
>
>正例：代码逻辑愤青红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，**使主干代码更加清晰**；**共性逻辑抽取成为共性方法，便于复用和维护**。

这里说的挺好的，该抽取的一定要抽取，冗长的代码真的不容易看出主干。

在这里我想贴一段Spring中DispatcherServlet的代码，我感觉这段代码的主干就很清晰，不会有别的碎片化代码影响你理清doDispatch()方法的流程：

~~~java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
		HttpServletRequest processedRequest = request;
		HandlerExecutionChain mappedHandler = null;
		boolean multipartRequestParsed = false;

		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

		try {
			ModelAndView mv = null;
			Exception dispatchException = null;

			try {
				processedRequest = checkMultipart(request);
				multipartRequestParsed = (processedRequest != request);

				// Determine handler for the current request.
        //获取当前请求的对应 HandlerExecutionChain
				mappedHandler = getHandler(processedRequest);
				if (mappedHandler == null || mappedHandler.getHandler() == null) {
					noHandlerFound(processedRequest, response);
					return;
				}

				// Determine handler adapter for the current request.
        //获取当前请求的对应 HandlerAdapter
				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

				// Process last-modified header, if supported by the handler.
				String method = request.getMethod();
				boolean isGet = "GET".equals(method);
				if (isGet || "HEAD".equals(method)) {
					long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
					if (logger.isDebugEnabled()) {
						logger.debug("Last-Modified value for [" + getRequestUri(request) + "] is: " + lastModified);
					}
					if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
						return;
					}
				}

				if (!mappedHandler.applyPreHandle(processedRequest, response)) {
					return;
				}

				// Actually invoke the handler.
        //真正调用请求的对应 Handler
				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

				if (asyncManager.isConcurrentHandlingStarted()) {
					return;
				}

				applyDefaultViewName(processedRequest, mv);
				mappedHandler.applyPostHandle(processedRequest, response, mv);
			}
			catch (Exception ex) {
				dispatchException = ex;
			}
			catch (Throwable err) {
				// As of 4.3, we're processing Errors thrown from handler methods as well,
				// making them available for @ExceptionHandler methods and other scenarios.
				dispatchException = new NestedServletException("Handler dispatch failed", err);
			}
			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
		}
		catch (Exception ex) {
			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
		}
		catch (Throwable err) {
			triggerAfterCompletion(processedRequest, response, mappedHandler,
					new NestedServletException("Handler processing failed", err));
		}
		finally {
			if (asyncManager.isConcurrentHandlingStarted()) {
				// Instead of postHandle and afterCompletion
				if (mappedHandler != null) {
					mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
				}
			}
			else {
				// Clean up any resources used by a multipart request.
				if (multipartRequestParsed) {
					cleanupMultipart(processedRequest);
				}
			}
		}
	}
~~~



#### (四)OOP 规约

>1.【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。

这里大家一般不会出错，静态元素的访问肯定是通过类名来调用的；

**TODO 只是这里A.staticField和new A().staticField，这两种调用在编译器或者虚拟机层面是具体怎么回事，有待了解**



>2.【强制】所有的覆写方法，必须加@Override注解。
>
>说明：getOnject()与get0bject()的问题。一个是字母的O，一个是数字的0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。

这里，其实加不加@Override注解，如果在抽象类中对方法签名进行修改，实现类也会报错，只不过是只会在类名那里报错，而如果加上@Override注解的话，在类名和方法名那里都会编译报错

